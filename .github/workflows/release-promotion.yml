name: Promote Release

on:
  workflow_dispatch:
    inputs:
      branch_pair:
        description: "Branch pair to use for promotion"
        required: true
        default: "test->main"
        type: choice
        options:
          - "test->main"
          - "v2/dev->v2/proto"
      action:
        description: "promote (dev -> prod) or archive (tag current prod)"
        required: true
        default: promote
        type: choice
        options: [promote, archive]
      release_type:
        description: "Version bump type (auto-increments from latest tag)"
        required: false
        default: patch
        type: choice
        options:
          - patch    # v0.3.1 -> v0.3.2 (bug fixes)
          - minor    # v0.3.1 -> v0.4.0 (new features)
          - major    # v0.3.1 -> v1.0.0 (breaking changes)
          - custom   # Use tag_name input instead
      tag_name:
        description: "Custom tag (only used when release_type is 'custom')"
        required: false
        type: string
      auto_merge:
        description: "Auto-merge PR and create release tag"
        required: false
        default: false
        type: boolean
      archive_tag:
        description: "Tag name when archiving (e.g., v1-archive)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  promote:
    if: ${{ github.event.inputs.action == 'promote' }}
    runs-on: ubuntu-latest
    steps:
      - name: Parse branch pair
        id: branches
        env:
          BRANCH_PAIR: ${{ github.event.inputs.branch_pair }}
        run: |
          SOURCE_BRANCH="${BRANCH_PAIR%->*}"
          TARGET_BRANCH="${BRANCH_PAIR#*->}"
          echo "source=$SOURCE_BRANCH" >> $GITHUB_OUTPUT
          echo "target=$TARGET_BRANCH" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Source: $SOURCE_BRANCH -> Target: $TARGET_BRANCH"

      - uses: actions/checkout@v6
        with:
          ref: ${{ steps.branches.outputs.source }}
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.23'

      - name: Run tests
        run: go test -v ./...

      - name: Calculate next version
        id: version
        env:
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}
          CUSTOM_TAG: ${{ github.event.inputs.tag_name }}
        run: |
          set -euo pipefail

          # Get latest tag
          LATEST_TAG=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1 || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          if [ "$RELEASE_TYPE" = "custom" ]; then
            if [ -z "${CUSTOM_TAG:-}" ]; then
              echo "Error: tag_name is required when release_type is 'custom'"
              exit 1
            fi
            NEXT_TAG="$CUSTOM_TAG"
          else
            # Parse version components
            VERSION="${LATEST_TAG#v}"
            MAJOR=$(echo "$VERSION" | cut -d. -f1)
            MINOR=$(echo "$VERSION" | cut -d. -f2)
            PATCH=$(echo "$VERSION" | cut -d. -f3)

            case "$RELEASE_TYPE" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEXT_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "Next tag: $NEXT_TAG"
          echo "tag=$NEXT_TAG" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG version
        id: changelog
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
        run: |
          set -euo pipefail
          VERSION="${TAG_NAME#v}"
          TODAY=$(date +%Y-%m-%d)
          if grep -qE "^## \[${VERSION}\]" CHANGELOG.md; then
            echo "âœ… CHANGELOG.md already contains entry for version ${VERSION}"
            echo "updated=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          UNRELEASED_CONTENT=$(sed -n '/^## \[Unreleased\]/,/^## \[/p' CHANGELOG.md | grep -E '^- ' || true)
          if [ -z "$UNRELEASED_CONTENT" ]; then
            echo "âŒ CHANGELOG.md has no unreleased changes to release"
            echo "Please add changelog entries under [Unreleased] before releasing"
            exit 1
          fi
          echo "ðŸ“ Updating CHANGELOG.md: [Unreleased] -> [${VERSION}] - ${TODAY}"
          printf '## [Unreleased]\n\n### Added\n\n### Changed\n\n### Fixed\n\n' > /tmp/unreleased.txt
          sed -i "s/^## \[Unreleased\]$/## [${VERSION}] - ${TODAY}/" CHANGELOG.md
          sed -i "/^## \[${VERSION}\]/e cat /tmp/unreleased.txt" CHANGELOG.md
          rm -f /tmp/unreleased.txt
          echo "âœ… CHANGELOG.md updated with version ${VERSION}"
          echo "Changes being released:"
          echo "$UNRELEASED_CONTENT"
          echo "updated=true" >> $GITHUB_OUTPUT

      - name: Commit CHANGELOG update
        id: changelog_commit
        if: steps.changelog.outputs.updated == 'true'
        continue-on-error: true
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
          SOURCE_BRANCH: ${{ steps.branches.outputs.source }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "Release ${TAG_NAME}: Update CHANGELOG version"
          git push origin "$SOURCE_BRANCH"
          echo "âœ… CHANGELOG update committed to $SOURCE_BRANCH branch"

      - name: Warn if CHANGELOG commit failed
        if: steps.changelog.outputs.updated == 'true' && steps.changelog_commit.outcome == 'failure'
        run: |
          echo "âš ï¸ Could not commit CHANGELOG update (branch protection may be blocking direct pushes)"
          echo "Please update CHANGELOG.md manually before merging the PR"

      - name: Create promotion PR
        id: pr
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}
          SOURCE_BRANCH: ${{ steps.branches.outputs.source }}
          TARGET_BRANCH: ${{ steps.branches.outputs.target }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          # Check if PR already exists
          EXISTING_PR=$(gh pr list --base "$TARGET_BRANCH" --head "$SOURCE_BRANCH" --json number --jq '.[0].number' || echo "")

          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for $SOURCE_BRANCH -> $TARGET_BRANCH"
            echo "URL: https://github.com/${{ github.repository }}/pull/$EXISTING_PR"
            echo "number=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "created=false" >> $GITHUB_OUTPUT
          else
            # Create PR to merge source into target
            PR_TITLE="Release ${TAG_NAME}: Promote $SOURCE_BRANCH to $TARGET_BRANCH"

            PR_URL=$(gh pr create \
              --base "$TARGET_BRANCH" \
              --head "$SOURCE_BRANCH" \
              --title "$PR_TITLE" \
              --body "## Summary

          Automated promotion of $SOURCE_BRANCH branch to $TARGET_BRANCH.

          **Version:** ${TAG_NAME}
          **Release type:** ${RELEASE_TYPE}

          ## Test plan

          - [x] All tests pass on $SOURCE_BRANCH branch
          - [ ] Review changes before merging

          ðŸ¤– Generated with GitHub Actions")

            # Extract PR number from URL
            PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
            echo "Created PR: $PR_URL"
            echo "number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "created=true" >> $GITHUB_OUTPUT
          fi

      - name: Trigger CI on new PR
        if: steps.pr.outputs.created == 'true'
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          GH_TOKEN: ${{ github.token }}
        run: |
          # GITHUB_TOKEN actions don't trigger workflows, so close/reopen to fire pull_request event
          echo "ðŸ”„ Triggering CI by reopening PR #${PR_NUMBER}..."
          gh pr close "$PR_NUMBER"
          gh pr reopen "$PR_NUMBER"
          echo "âœ… CI workflows should now be running"

      - name: Add PR link to CHANGELOG
        if: steps.pr.outputs.created == 'true'
        continue-on-error: true
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          SOURCE_BRANCH: ${{ steps.branches.outputs.source }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          VERSION="${TAG_NAME#v}"
          REPO="${{ github.repository }}"
          PR_LINK="([#${PR_NUMBER}](https://github.com/${REPO}/pull/${PR_NUMBER}))"

          # Check if any PR link already exists on the version line
          if grep -qE "^## \[${VERSION}\].*\(#[0-9]+\)" CHANGELOG.md; then
            echo "Version line already has a PR link in CHANGELOG.md"
            exit 0
          fi

          # Add PR link to the version line (use | delimiter to avoid conflicts with URLs)
          sed -i "s|^## \[${VERSION}\] - \([0-9-]*\)$|## [${VERSION}] - \1 ${PR_LINK}|" CHANGELOG.md

          # Check if there are changes to commit
          if git diff --quiet CHANGELOG.md; then
            echo "No changes to CHANGELOG.md (version line format may not match expected pattern)"
            exit 0
          fi

          # Commit and push the change
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "Add PR #${PR_NUMBER} link to CHANGELOG for ${TAG_NAME}"
          git push origin "$SOURCE_BRANCH" || echo "âš ï¸ Could not push PR link update (branch protection)"

          echo "âœ… Added PR #${PR_NUMBER} link to CHANGELOG.md"

      - name: Auto-merge PR and create tag
        if: ${{ github.event.inputs.auto_merge == 'true' }}
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          TARGET_BRANCH: ${{ steps.branches.outputs.target }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          echo "ðŸ”„ Merging PR #${PR_NUMBER}..."

          # Wait for any status checks to complete
          sleep 5

          # Merge the PR
          gh pr merge "$PR_NUMBER" --merge --delete-branch=false

          echo "âœ… PR #${PR_NUMBER} merged to $TARGET_BRANCH"

          # Fetch latest target branch
          git fetch origin "$TARGET_BRANCH"

          # Create and push tag on target branch
          echo "ðŸ·ï¸  Creating tag ${TAG_NAME} on $TARGET_BRANCH..."
          git tag "$TAG_NAME" "origin/$TARGET_BRANCH"
          git push origin "$TAG_NAME"

          echo "âœ… Tag ${TAG_NAME} created and pushed"
          echo "ðŸš€ Release workflow will be triggered automatically"

  archive:
    if: ${{ github.event.inputs.action == 'archive' }}
    runs-on: ubuntu-latest
    steps:
      - name: Parse branch pair
        id: branches
        env:
          BRANCH_PAIR: ${{ github.event.inputs.branch_pair }}
        run: |
          TARGET_BRANCH="${BRANCH_PAIR#*->}"
          echo "target=$TARGET_BRANCH" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Archiving target branch: $TARGET_BRANCH"

      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Archive current target branch
        env:
          ARCHIVE_TAG: ${{ github.event.inputs.archive_tag }}
          TARGET_BRANCH: ${{ steps.branches.outputs.target }}
        run: |
          set -euo pipefail
          git fetch origin

          # Tag the current target branch for archive
          if [ -z "${ARCHIVE_TAG:-}" ]; then
            echo "Error: archive_tag is required"
            exit 1
          fi

          git tag -f "$ARCHIVE_TAG" "origin/$TARGET_BRANCH"
          git push origin "$ARCHIVE_TAG" --force
          echo "âœ… Archived $TARGET_BRANCH as $ARCHIVE_TAG"